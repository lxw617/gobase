# 1.

```go
package main

import "fmt"

func main() {
	nums := []int{3, 2, 4}
	target := 6
	index := twoSum(nums, target)
	fmt.Println(index)
}
func twoSum(nums []int, target int) []int {
	var index []int
	var res []int
	hashSet := make(map[int]struct{})
	for k1 := 0; k1 < len(nums); k1++ {
		for k2 := 0; k2 < len(nums); k2++ {
			num1 := nums[k1]
			num2 := nums[k2]
			if num1+num2 == target && k1 != k2 {
				index = append(index, k1)
				index = append(index, k2)
			}
			for _, v := range index {
				hashSet[v] = struct{}{}
			}
		}
	}
	for k, _ := range hashSet {
		res = append(res, k)
	}
	return res
}

```

# 3.

```go
package main

import (
	"fmt"
)

func main() {
	s := "pwwkew"
	i := lengthOfLongestSubstring(s)
	fmt.Println(i)
}
func lengthOfLongestSubstring(s string) int {
	l, r, max := 0, 0, 0
	m := map[byte]int{}
	for ; r < len(s); r++ {
		v := s[r]
		if _, ok := m[v]; !ok {
			m[v] = r
		} else {
			//更新r，设置l=之前的r+1
			if m[v]+1 >= l {
				l = m[v] + 1
			}
			m[v] = r
		}
		if r-l+1 > max {
			max = r - l + 1
		}
		fmt.Println(m)
	}
	return max
}

/*
l, r, Max := 0, 0, 0
	m := map[byte]int{}
	for ; r < len(s); r++ {
		fmt.Println(m[s[r]])
		fmt.Println(string(s[r]))
		if _, ok := m[s[r]]; !ok {
			m[s[r]] = r
		} else {
			if m[s[r]]+1 >= l {
				l = m[s[r]] + 1
			}
			m[s[r]] = r
		}
		if r-l+1 > Max {
			Max = r - l + 1
		}
	}
	return Max
*/

```



# 5.

```go
package main

import "fmt"

func main() {
	s := "babad"
	fmt.Println(longestPalindrome(s))
}
func longestPalindrome(s string) string {
	left, right, max, l, r := 0, 1, 0, 0, 0

	for i := 0; i < len(s); i++ {
		if s[left] == s[right] {
			if left-1 >= 0 {
				left--
				right++
			}
		} else {
			left++
			right++
		}
		if right-left+1 > max {
			max = right - left + 1
			l = left
			r = right + 1
		}
	}
	ss := s[l:r]
	return ss
}

```



# 26.

```go
package main

import "fmt"

func main() {
	nums := []int{0, 0, 1, 1, 1, 2, 2, 3, 3, 4}
	l := removeDuplicates(nums)
	fmt.Println(l)
}
func removeDuplicates(nums []int) int {
	hashSet := make(map[int]struct{})
	for _, v := range nums {
		hashSet[v] = struct{}{}
	}
	return len(hashSet)
}

```



# 175.组合两个表

```sql
select p.firstName as firstName, p.lastName as lastName,a.city as city, a.state as state from person p left join address a on p.personId = a.personId
-- 注意题目要求地址表中没有 personId = 1 的地址，所以它们的城市和州返回 null。addressId = 1 包含了 personId = 2 的地址信息。
```



# 176.第二高的薪水

```sql
select IFNULL((select distinct salary from Employee order by salary desc limit 1 offset 1),null) as SecondHighestSalary
```



```sql
补充：

1 聚合函数：max聚合，再过滤最大值

select ifnull(
    (select max(salary) 
    from Employee
    where salary < (select max(salary) from Employee)
    ),null
) as SecondHighestSalary;

2.1 排序法：先排序后分页查询

select(
    select distinct salary
    from Employee
    order by salary desc
    limit 1 offset 1
) as SecondHighestSalary; 

2.2 排序：用窗口函数进行排序

select (
    select salary 
    from(
        select distinct(salary), rank() over(order by salary desc) as ranking
        from Employee
    ) as rankTable
    where ranking = 2
) as SecondHighestSalary；

总结

    ifnull 对查询速度的影响不大，加上可以提高可读性；
    加不加 as 来改名对速度影响不大，但建议加，以提升可读性；
    窗口函数适合的使用场景是“分组排序”，当然也可以不分组来直接解决排序查询任务，但影响了查询效率，代码量也大，不建议。优点是可以直接排序查询，并且很直观；但是缺点是查询速度会慢很多，可能是由于中间添加rank列并生成临时表的操作影响了查询速度。窗口函数的语法如下：

<窗口函数> over (partition by <用于分组的列名>
                order by <用于排序的列名>)


```



# 177.第N高的薪水

```sql
CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT
BEGIN
SET N = N - 1;
  RETURN (
      # Write your MySQL query statement below. 
select IFNULL((select distinct salary from Employee order by salary desc limit 1 offset N),null) as SecondHighestSalary
  );
END
```



# 178.分数排名

```sql
方法1： dense_rank() over(order by 排序字段 desc/asc)：排序函数是相同数值相同序号，且序号是顺序的。 方法2： 排序序号是由大于等于当前分数的，且分数不同的人的个数组成的，所以要先按id（不同的人）分组，再计算不同分数的人的个数，作为排序的序号，展示结果按分数的降序进行。

select score, dense_rank() over(order by score desc) as 'rank' from scores 

性能问题（直接思维）
SELECT score, (SELECT count(DISTINCT score) FROM Scores WHERE score >= s.score) AS 'rank' FROM Scores s ORDER BY Score DESC ;


思路： 1.从两张相同的表scores分别命名为s1，s2。 2.s1中的score与s2中的score比较大小。意思是在输出s1.score的前提下，有多少个s2.score大于等于它。比如当s1.salary=3.65的时候，s2.salary中[4.00,4.00,3.85,3.65,3.65]有5个成绩大于等于他，但是利用count(distinct s2.score)去重可得s1.salary3.65的rank为3 3.group by s1.id 不然的话只会有一条数据 4.最后根据s1.score排序desc

select s1.score,count(distinct s2.score) as rank
from scores as s1,scores as s2
where s1.score<=s2.score
group by s1.id
order by s1.score desc;
```



# 数据库补充



## IFNULL

```sql
IFNULL() 函数用于判断第一个表达式是否为 NULL，如果为 NULL 则返回第二个参数的值，如果不为 NULL 则返回第一个参数的值。
IFNULL() 函数语法格式为：
IFNULL(expression, alt_value)
如果第一个参数的表达式 expression 为 NULL，则返回第二个参数的备用值。

参数说明:
参数 描述
expression 必须，要测试的值
alt_value 必须，expression 表达式为 NULL 时返回的值

实例
第一个参数为 NULL：
SELECT IFNULL(NULL, “RUNOOB”);
以上实例输出结果为：
RUNOOB

第一个参数不为 NULL：
SELECT IFNULL(“Hello”, “RUNOOB”);
以上实例输出结果为：
Hello

原文链接：https://blog.csdn.net/yajie_12/article/details/102583061
```



## DISTINCT

```sql
distinct用来查询不重复记录的条数,即用distinct来返回不重复字段的条数（count(distinct id)）,其原因是distinct只能返回他的目标字段，而无法返回其他字段。

注意事项
distinct 【查询字段】，必须放在要查询字段的开头，即放在第一个参数；
只能在SELECT 语句中使用，不能在 INSERT, DELETE, UPDATE 中使用；
DISTINCT 表示对后面的所有参数的拼接取不重复的记录，即查出的参数拼接每行记录都是唯一的。不能与all同时使用，默认情况下，查询时返回的就是所有的结果。

使用实例
只对一个字段查重：表示选取该字段一列不重复的数据。
多个字段去重：表示选取多个字段拼接的一条记录，不重复的所有记录。改进：使用 group_concat 函数；使用group by函数。
聚合函数中使用distinct：一般跟 COUNT 结合使用, count()会过滤掉null项，即null项不进行计数。


原文链接：https://blog.csdn.net/shenziheng1/article/details/102536146
```

## 四大排名函数

**一、ROW_NUMBER()**
Row_number() 在排名是序号 连续 不重复，即使遇到表中的两个一样的数值亦是如此

```sql
select *,row_number() OVER(order by number ) as row_num from num 
```



数据如下：

![1.png](assets/1623029150-HoIqOw-1.png)

结果如图：

![2.png](assets/1623029160-OIBonQ-2.png)

注意：在使用row_number() 实现分页时需要特别注意一点，over子句中的order by 要与SQL排序记录中的order by保持一致，否则得到的序号可能不是连续的
select *,row_number() OVER(order by number ) as row_num from num ORDER BY id

![3.png](assets/1623029174-rBBBpX-3.png)

**二、rank()**
Rank() 函数会把要求排序的值相同的归为一组且每组序号一样，排序不会连续执行

select *,rank() OVER(order by number ) as row_num from num 

结果如下：

![4.png](assets/1623029183-THUYoe-4.png)

**三、dense_rank()**
Dense_rank() 排序是连续的，也会把相同的值分为一组且每组排序号一样

select *,dense_rank() OVER(order by number ) as row_num from num 

结果如下：

![5.png](assets/1623029200-APlyUj-5.png)

**四、ntile()**
Ntile(group_num) 将所有记录分成group_num个组，每组序号一样

select *,ntile(2) OVER(order by number ) as row_num from num 

![6.png](assets/1623029213-kgvvyl-6-1660641514911.png)



```sql
一、ROW_NUMBER()
Row_number() 在排名是序号，连续，不重复，即使遇到表中的两个一样的数值亦是如此。
注意：在使用row_number() 实现分页时需要特别注意一点，over子句中的order by 要与SQL排序记录中的order by保持一致，否则得到的序号可能不是连续的。
二、rank()
Rank() 函数会把要求排序的值相同的归为一组且每组序号一样，排序不会连续执行。
三、dense_rank()
Dense_rank() 排序是连续的，也会把相同的值分为一组且每组排序号一样。
四、ntile()
Ntile(group_num) 将所有记录分成group_num个组，每组序号一样。
```

